<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EtxekoApp — Tareas y Notas</title>
  <meta name="theme-color" content="#0a0a0a" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ["Inter", "ui-sans-serif", "system-ui"] },
          colors: {
            surface: {
              50: "#fafafa",
              100: "#f5f5f5",
              900: "#0a0a0a",
            }
          },
          boxShadow: {
            soft: "0 10px 30px rgba(0,0,0,0.35)",
          }
        }
      }
    }
  </script>
  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Firebase (Compat para uso sencillo con un único HTML) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <!-- Chart.js para gráficos -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-neutral-950 text-neutral-100 antialiased">
  <div id="root"></div>

  <script type="text/javascript">
    // Inicializa Firebase con tus datos
    const firebaseConfig = {
      apiKey: "AIzaSyApVxmFp3bcogwMqaz0MQiIng6XzGwhTvY",
      authDomain: "etxekoapp.firebaseapp.com",
      projectId: "etxekoapp",
      storageBucket: "etxekoapp.firebasestorage.app",
      messagingSenderId: "1031385135784",
      appId: "1:1031385135784:web:1018c0dadb87769495209d"
    };
    firebase.initializeApp(firebaseConfig);
    window.db = firebase.firestore();
  </script>

  <script type="text/babel">
    const { useEffect, useMemo, useState, useRef } = React;

    // ==========================
    // Utilidades de fecha
    // ==========================
    const todayISO = () => {
      const d = new Date();
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };
    const toISO = (d) => new Date(d).toISOString().slice(0, 10);
    const addDays = (dateISO, days) => {
      const d = new Date(dateISO + "T00:00:00");
      d.setDate(d.getDate() + days);
      return toISO(d);
    };
    const addYears = (dateISO, years) => {
      const d = new Date(dateISO + "T00:00:00");
      d.setFullYear(d.getFullYear() + years);
      return toISO(d);
    };
    const startOfDay = (d) => new Date(new Date(d).toDateString());
    const isSameDay = (aISO, bISO) => startOfDay(aISO).getTime() === startOfDay(bISO).getTime();
    const isBefore = (aISO, bISO) => startOfDay(aISO) < startOfDay(bISO);
    const weekdayOfISO = (iso) => new Date(iso + "T00:00:00").getDay(); // 0=Dom

    function computeNextDue(task, fromISO) {
      const base = fromISO || todayISO(); // Siempre buscar desde hoy o la fecha proporcionada
      const type = task.frequencyType || "interval";
      
      if (type === "interval") {
        const n = Math.max(1, Number(task.intervalDays || 7));
        return addDays(base, n);
      }
      if (type === "weekly") {
        const set = (task.weekdays && task.weekdays.length ? task.weekdays : [1]).sort();
        let currentDate = new Date(base + "T00:00:00");
        // Iterar hasta encontrar el siguiente día válido
        for (let i = 0; i < 14; i++) { // Buscar hasta 2 semanas en el futuro para asegurar un match
          currentDate.setDate(currentDate.getDate() + 1); // Avanzar un día
          const candISO = toISO(currentDate);
          if (set.includes(weekdayOfISO(candISO))) {
            return candISO;
          }
        }
        return addDays(base, 7); // Fallback si no se encuentra en 2 semanas
      }
      if (type === "monthly") {
        const mdays = (task.monthDays && task.monthDays.length ? task.monthDays : [1]).sort((a,b)=>a-b);
        let d = new Date(base + "T00:00:00");
        for (let i = 1; i <= 62; i++) {
          d.setDate(d.getDate() + 1);
          const day = d.getDate();
          const cand = toISO(d);
          if (mdays.includes(day)) return cand;
        }
        return addDays(base, 30);
      }
      if (type === "yearly") { // Nueva frecuencia anual
        return addYears(base, 1);
      }
      if (type === "specificDays") {
        const wSet = (task.weekdays && task.weekdays.length ? task.weekdays : []);
        const mSet = (task.monthDays && task.monthDays.length ? task.monthDays : []);
        const hasW = wSet.length > 0;
        const hasM = mSet.length > 0;
        let baseDate = new Date(base + "T00:00:00");
        for (let i = 0; i < 62; i++) { // Buscar hasta 2 meses en el futuro
          baseDate.setDate(baseDate.getDate() + 1);
          const cand = toISO(baseDate);
          const w = baseDate.getDay();
          const m = baseDate.getDate();
          if ((hasW && hasM && wSet.includes(w) && mSet.includes(m)) ||
              (hasW && !hasM && wSet.includes(w)) ||
              (!hasW && hasM && mSet.includes(m))) {
            return cand;
          }
        }
        return addDays(base, 7); // Fallback
      }
      return addDays(base, 7);
    }

    // ==========================
    // App principal
    // ==========================
    function App() {
      const [tab, setTab] = useState("hoy"); // hoy | todas | notas | historial | stats
      const [query, setQuery] = useState("");
      const [roomFilter, setRoomFilter] = useState("todas");
      const [notificationPermission, setNotificationPermission] = useState("default");
      const [sortKey, setSortKey] = useState("nextDue"); // Estado para la clave de ordenación
      const [sortOrder, setSortOrder] = useState("asc"); // Estado para el orden de ordenación (asc/desc)

      const [tasks, setTasks] = useState([]);
      const [notes, setNotes] = useState([]);
      const [historyTasks, setHistoryTasks] = useState([]); // Nuevo estado para historial
      const [loading, setLoading] = useState(true);

      // Suscripción a Firestore
      useEffect(() => {
        const unsubTasks = db.collection("tareas").orderBy("createdAt", "desc").onSnapshot((snap) => {
          const list = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
          setTasks(list);
          setLoading(false);
        });
        const unsubNotes = db.collection("notas").orderBy("createdAt", "desc").onSnapshot((snap) => {
          setNotes(snap.docs.map((d) => ({ id: d.id, ...d.data() })));
        });
        // Suscripción a la nueva colección de historial
        const unsubHistoryTasks = db.collection("historialTareas").orderBy("completedAt", "desc").onSnapshot((snap) => {
          setHistoryTasks(snap.docs.map((d) => ({ id: d.id, ...d.data() })));
        });

        return () => { 
          unsubTasks(); 
          unsubNotes(); 
          unsubHistoryTasks(); // Limpiar suscripción de historial
        };
      }, []);

      // Pedir permiso para notificaciones
      useEffect(() => {
        if ("Notification" in window) {
          setNotificationPermission(Notification.permission);
          if (Notification.permission === "default") {
            Notification.requestPermission().then(permission => {
              setNotificationPermission(permission);
            });
          }
        }
      }, []);

      // Mostrar notificaciones para tareas de hoy
      useEffect(() => {
        if (notificationPermission !== "granted") return;
        
        const today = todayISO();
        const todayTasks = tasks.filter(t => 
          t.nextDue === today && 
          !t.completed && 
          (!t.lastNotified || t.lastNotified !== today)
        );
        
        if (todayTasks.length > 0) {
          new Notification("Tareas de hoy", {
            body: `Tienes ${todayTasks.length} tareas pendientes para hoy.`,
            icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23059669'><path d='M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z'/></svg>"
          });
          
          // Actualizar última notificación
          todayTasks.forEach(task => {
            db.collection("tareas").doc(task.id).update({ lastNotified: today });
          });
        }
      }, [tasks, notificationPermission]);

      const rooms = useMemo(() => {
        // Incluir las estancias predefinidas y las que ya existen en las tareas
        const defaultRooms = ["General", "Baños", "Dormitorios", "Cocina", "Salon", "Balcon"];
        const existingRooms = new Set(tasks.map((t) => t.room).filter(Boolean));
        return ["todas", ...defaultRooms, ...Array.from(existingRooms)].filter((value, index, self) => self.indexOf(value) === index);
      }, [tasks]);

      const normalized = useMemo(() => {
        return tasks.map((t) => ({
          ...t,
          nextDue: t.nextDue || computeNextDue(t, t.lastDone || todayISO()),
        }));
      }, [tasks]);

      const today = todayISO();

      const filtered = useMemo(() => {
        const q = query.trim().toLowerCase();
        return normalized
          .filter((t) => (roomFilter === "todas" ? true : (t.room || "").toLowerCase() === roomFilter.toLowerCase()))
          .filter((t) => (q ? `${t.title} ${t.room} ${t.notes}`.toLowerCase().includes(q) : true));
      }, [normalized, roomFilter, query]);

      const sortTasks = (tasksList, currentSortKey, currentSortOrder, isHistoryData = false) => {
        return tasksList.slice().sort((a, b) => {
          let valA, valB;
          if (isHistoryData) {
            valA = a[currentSortKey] ? a[currentSortKey].toDate().getTime() : 0;
            valB = b[currentSortKey] ? b[currentSortKey].toDate().getTime() : 0;
          } else {
            valA = a[currentSortKey] || "";
            valB = b[currentSortKey] || "";
          }
          
          if (currentSortKey === "title" || currentSortKey === "room") {
            return currentSortOrder === "asc" 
              ? String(valA).localeCompare(String(valB)) 
              : String(valB).localeCompare(String(valA));
          } else if (currentSortKey === "nextDue" || currentSortKey === "completedAt") {
            // Comparar fechas si es un campo de fecha
            const dateA = new Date(valA);
            const dateB = new Date(valB);
            return currentSortOrder === "asc" ? dateA - dateB : dateB - dateA;
          }
          return 0; // No change
        });
      };

      const tasksToday = useMemo(() => {
        return sortTasks(
          filtered.filter((t) => isSameDay(t.nextDue, today)),
          sortKey,
          sortOrder
        );
      }, [filtered, today, sortKey, sortOrder]);

      const tasksAll = useMemo(() => {
        return sortTasks(filtered, sortKey, sortOrder);
      }, [filtered, sortKey, sortOrder]);

      const historyTasksSorted = useMemo(() => {
        // Por defecto, historial se ordena por completedAt descendente
        return sortTasks(historyTasks, "completedAt", "desc", true); 
      }, [historyTasks]);


      // Acciones Firestore
      const createTask = async (t) => {
        const base = {
          title: "",
          room: "General",
          notes: "",
          frequencyType: "weekly",
          weekdays: [1],
          monthDays: [],
          intervalDays: 7,
          lastDone: todayISO(),
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        };
        const task = { ...base, ...t };
        await db.collection("tareas").add(task);
      };

      const updateTask = async (id, patch) => {
        const ref = db.collection("tareas").doc(id);
        const snap = await ref.get();
        if (!snap.exists) return;
        const cur = { id: snap.id, ...snap.data() };
        const next = { ...cur, ...patch };
        await ref.update(next);
      };

      const removeTask = async (id) => {
        const confirmDelete = await showCustomConfirm("¿Eliminar esta tarea?", "Esta acción es irreversible.");
        if (!confirmDelete) return;
        await db.collection("tareas").doc(id).delete();
      };

      const removeHistoryTask = async (id) => {
        const confirmDelete = await showCustomConfirm("¿Eliminar esta tarea del historial?", "Esta acción es irreversible.");
        if (!confirmDelete) return;
        await db.collection("historialTareas").doc(id).delete();
      };

      const removeAllHistoryTasks = async () => {
        const confirmDelete = await showCustomConfirm(
          "¿Eliminar TODAS las tareas del historial?", 
          "Esta acción es irreversible y eliminará todos los registros de tareas completadas."
        );
        if (!confirmDelete) return;

        const historyCollectionRef = db.collection("historialTareas");
        const snapshot = await historyCollectionRef.get();
        const batch = db.batch();

        snapshot.docs.forEach(doc => {
          batch.delete(doc.ref);
        });

        await batch.commit();
        showCustomAlert("Todas las tareas del historial han sido eliminadas.");
      };


      const markDone = async (id) => {
        const now = todayISO();
        const taskRef = db.collection("tareas").doc(id);
        const taskSnap = await taskRef.get();
        if (!taskSnap.exists) return;
        const taskData = taskSnap.data();

        // Añadir la tarea actual al historial
        await db.collection("historialTareas").add({
          ...taskData,
          originalTaskId: id, // Guardar el ID original de la tarea
          completedAt: firebase.firestore.FieldValue.serverTimestamp(),
          status: "done"
        });

        // Calcular la próxima fecha de vencimiento para la tarea original
        // y actualizarla en la colección 'tareas' para que siga siendo recurrente
        const updatedTaskData = {
          ...taskData,
          lastDone: now, // La tarea se ha completado hoy
          nextDue: computeNextDue(taskData, now) // Calcular la próxima fecha a partir de hoy
        };
        await taskRef.update(updatedTaskData);
      };

      const postpone = async (id, days = 1) => {
        const t = tasks.find((x) => x.id === id);
        const newNext = addDays((t?.nextDue || todayISO()), days);
        await updateTask(id, { nextDue: newNext });
      };

      // Notas
      const createNote = async (n) => {
        const base = {
          title: "",
          content: "",
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        };
        await db.collection("notas").add({ ...base, ...n });
      };
      const updateNote = async (id, patch) => {
        await db.collection("notas").doc(id).update(patch);
      };
      const removeNote = async (id) => {
        const confirmDelete = await showCustomConfirm("¿Eliminar esta nota?", "Esta acción es irreversible.");
        if (!confirmDelete) return;
        await db.collection("notas").doc(id).delete();
      };

      return (
        <div className="min-h-screen">
          <Header 
            tab={tab} 
            setTab={setTab} 
            tasksTodayCount={tasksToday.length} 
            notificationPermission={notificationPermission}
          />

          <main className="max-w-6xl mx-auto px-4 pb-28">
            <Toolbar
              tab={tab} // Pasamos la pestaña actual a Toolbar
              query={query}
              setQuery={setQuery}
              roomFilter={roomFilter}
              setRoomFilter={setRoomFilter}
              rooms={rooms}
              onCreateTask={() => openTaskModal({ onSave: createTask, rooms: rooms })}
              onCreateNote={() => openNoteModal({ onSave: createNote })}
              sortKey={sortKey} // Pasamos el estado de ordenación
              setSortKey={setSortKey} // Pasamos la función para cambiar el estado de ordenación
              sortOrder={sortOrder}
              setSortOrder={setSortOrder}
            />

            {tab === "hoy" && (
              <SectionList
                title={`Tareas de hoy (${formatDateHuman(today)})`}
                empty="Hoy no tienes tareas programadas. ¡Disfruta!"
                tasks={tasksToday}
                onEdit={(t) => openTaskModal({ task: t, onSave: (patch) => updateTask(t.id, patch), rooms: rooms })}
                onDone={(id) => markDone(id)}
                onPostpone={(id) => postpone(id, 1)}
                onRemove={removeTask}
              />
            )}

            {tab === "todas" && (
              <SectionList
                title="Todas las tareas"
                empty="Crea tu primera tarea con el botón de arriba."
                tasks={tasksAll}
                onEdit={(t) => openTaskModal({ task: t, onSave: (patch) => updateTask(t.id, patch), rooms: rooms })}
                onDone={(id) => markDone(id)}
                onPostpone={(id) => postpone(id, 1)}
                onRemove={removeTask}
              />
            )}

            {tab === "notas" && (
              <NotesSection
                notes={notes}
                onCreate={() => openNoteModal({ onSave: createNote })}
                onEdit={(n) => openNoteModal({ note: n, onSave: (patch) => updateNote(n.id, patch) })}
                onRemove={removeNote}
              />
            )}

            {tab === "historial" && ( // Nuevo tab de historial
              <SectionList
                title="Historial de tareas completadas"
                empty="Aún no hay tareas en el historial."
                tasks={historyTasksSorted} // Mostrar tareas del historial ordenadas
                onRemove={removeHistoryTask} // Permitir eliminar tareas individuales del historial
                onClearAll={removeAllHistoryTasks} // Nuevo prop para eliminar todo el historial
              />
            )}

            {tab === "stats" && (
              <Stats tasks={normalized} historyTasks={historyTasks} />
            )}
          </main>

          <BottomBar onCreateTask={() => openTaskModal({ onSave: createTask, rooms: rooms })} onCreateNote={() => openNoteModal({ onSave: createNote })} />

          {/* Portales para modales */}
          <div id="modal-root"></div>
        </div>
      );
    }

    // =====================================
    // UI Components
    // =====================================
    function Header({ tab, setTab, tasksTodayCount, notificationPermission }) {
      return (
        <header className="sticky top-0 z-20 backdrop-blur supports-[backdrop-filter]:bg-neutral-900/60 bg-neutral-900/90 border-b border-neutral-800">
          <div className="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
            <div className="size-9 rounded-2xl bg-gradient-to-br from-emerald-400 to-teal-500 shadow-soft" />
            <div className="flex-1">
              <h1 className="text-xl font-semibold leading-tight">EtxekoApp</h1>
              <p className="text-xs text-neutral-400">Tareas y notas del hogar</p>
            </div>
            <div className="flex items-center gap-2">
              {notificationPermission === "granted" && (
                <span className="hidden md:inline text-xs text-emerald-400">✓ Notificaciones activas</span>
              )}
              {notificationPermission === "denied" && (
                <span className="hidden md:inline text-xs text-amber-400">⚠ Notificaciones bloqueadas</span>
              )}
              <a href="https://firebase.google.com/" target="_blank" className="hidden md:inline text-xs text-neutral-400 hover:text-neutral-200">Firebase conectado</a>
            </div>
          </div>
          <div className="max-w-6xl mx-auto px-4 pb-3 flex flex-wrap items-center gap-2">
            <div className="flex gap-2 bg-neutral-800/70 rounded-xl p-1">
              {[
                { key: "hoy", label: `Hoy${tasksTodayCount ? ` (${tasksTodayCount})` : ''}` },
                { key: "todas", label: "Todas" },
                { key: "notas", label: "Notas" },
                { key: "historial", label: "Historial" },
                { key: "stats", label: "Estadísticas" },
              ].map((t) => (
                <button
                  key={t.key}
                  onClick={() => setTab(t.key)}
                  className={`px-3 py-1.5 rounded-lg text-sm font-medium transition ${
                    tab === t.key ? "bg-neutral-100 text-neutral-900" : "text-neutral-300 hover:bg-neutral-700"
                  }`}
                >
                  {t.label}
                </button>
              ))}
            </div>
          </div>
        </header>
      );
    }

    function Toolbar({ tab, query, setQuery, roomFilter, setRoomFilter, rooms, onCreateTask, onCreateNote, sortKey, setSortKey, sortOrder, setSortOrder }) {
      const showNewTaskButton = tab === "hoy" || tab === "todas";
      const showNewNoteButton = tab === "notas";
      const showSortingOptions = tab === "todas" || tab === "historial";

      const sortOptions = useMemo(() => {
        if (tab === "historial") {
          return [
            { value: "completedAt_desc", label: "Completado (Reciente)" },
            { value: "completedAt_asc", label: "Completado (Antiguo)" },
            { value: "title_asc", label: "Título (A-Z)" },
            { value: "title_desc", label: "Título (Z-A)" },
            { value: "room_asc", label: "Estancia (A-Z)" },
            { value: "room_desc", label: "Estancia (Z-A)" },
          ];
        } else { // 'hoy' y 'todas'
          return [
            { value: "nextDue_asc", label: "Próxima Fecha (Pronto)" },
            { value: "nextDue_desc", label: "Próxima Fecha (Tarde)" },
            { value: "title_asc", label: "Título (A-Z)" },
            { value: "title_desc", label: "Título (Z-A)" },
            { value: "room_asc", label: "Estancia (A-Z)" },
            { value: "room_desc", label: "Estancia (Z-A)" },
          ];
        }
      }, [tab]);

      // Manejar el cambio de ordenación
      const handleSortChange = (e) => {
        const [key, order] = e.target.value.split('_');
        setSortKey(key);
        setSortOrder(order);
      };

      // Establecer la ordenación por defecto cuando cambia de pestaña
      useEffect(() => {
        if (tab === "historial") {
          setSortKey("completedAt");
          setSortOrder("desc");
        } else if (tab === "hoy" || tab === "todas") {
          setSortKey("nextDue");
          setSortOrder("asc");
        }
      }, [tab, setSortKey, setSortOrder]);


      return (
        <div className="mt-4 mb-2 flex flex-col md:flex-row gap-2 md:items-center">
          <div className="flex-1 flex gap-2">
            <div className="relative w-full md:w-80">
              <input
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Buscar tareas…"
                className="w-full pl-9 pr-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500"
              />
              <div className="absolute left-3 top-2.5 text-neutral-500">🔎</div>
            </div>
            <select
              value={roomFilter}
              onChange={(e) => setRoomFilter(e.target.value)}
              className="px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800"
            >
              {rooms.map((r) => (
                <option key={r} value={r}>{r}</option>
              ))}
            </select>
            {showSortingOptions && (
              <select
                value={`${sortKey}_${sortOrder}`}
                onChange={handleSortChange}
                className="px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800"
              >
                {sortOptions.map((o) => (
                  <option key={o.value} value={o.value}>{o.label}</option>
                ))}
              </select>
            )}
          </div>
          <div className="flex gap-2">
            {showNewTaskButton && (
              <button onClick={onCreateTask} className="px-3 py-2 rounded-xl bg-emerald-500 text-black font-medium hover:bg-emerald-400 shadow">+ Nueva tarea</button>
            )}
            {showNewNoteButton && (
              <button onClick={onCreateNote} className="px-3 py-2 rounded-xl bg-teal-500 text-black font-medium hover:bg-teal-400 shadow">+ Nueva nota</button>
            )}
          </div>
        </div>
      );
    }

    function SectionList({ title, empty, tasks, onEdit, onDone, onPostpone, onRemove, onClearAll }) {
      const isHistorySection = title.includes("Historial"); // Determina si es la sección de historial

      return (
        <section className="py-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">{title}</h2>
            {isHistorySection && tasks.length > 0 && (
              <button
                onClick={onClearAll}
                className="px-3 py-1.5 rounded-xl bg-red-700/50 text-red-300 font-medium hover:bg-red-700/70 shadow"
              >
                Eliminar todo el historial
              </button>
            )}
          </div>
          {tasks.length === 0 ? (
            <p className="text-neutral-400">{empty}</p>
          ) : (
            <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-3">
              {tasks.map((t) => (
                <TaskCard 
                  key={t.id} 
                  t={t} 
                  onEdit={onEdit} 
                  onDone={onDone} 
                  onPostpone={onPostpone} 
                  onRemove={onRemove} 
                  isHistory={isHistorySection} 
                />
              ))}
            </div>
          )}
        </section>
      );
    }

    function TaskCard({ t, onEdit, onDone, onPostpone, onRemove, isHistory }) {
      const dueToday = isSameDay(t.nextDue, todayISO());
      const overdue = isBefore(t.nextDue, todayISO());
      
      return (
        <div className="rounded-2xl border border-neutral-800 bg-neutral-900 p-4 flex flex-col gap-3 hover:border-neutral-700 transition">
          <div className="flex items-start gap-3">
            <div className={`size-2 mt-2 rounded-full ${
              overdue ? "bg-red-400" : 
              dueToday ? "bg-amber-400" : 
              isHistory ? "bg-gray-500" : "bg-emerald-400" 
            }`} />
            <div className="flex-1">
              <h3 className="font-semibold leading-tight">{t.title}</h3>
              <p className="text-xs text-neutral-400">
                {t.room || "General"} 
              </p>
              {t.notes && <p className="text-sm text-neutral-300 mt-1">{t.notes}</p>}
            </div>
            {onRemove && ( // Mostrar botón de eliminar solo si onRemove está definido (para tareas activas e historial)
              <button onClick={() => onRemove(t.id)} className="text-neutral-400 hover:text-red-400">Eliminar</button>
            )}
            {isHistory && ( 
              <div className="text-xs text-neutral-400">Completado: {t.completedAt ? toISO(t.completedAt.toDate()) : 'N/A'}</div>
            )}
          </div>
          {!isHistory && ( // Ocultamos los detalles de próxima y última vez para tareas del historial
            <div className="flex items-center justify-between text-sm">
              <div className="text-neutral-300">
                <div>Última vez: <span className="text-neutral-100">{t.lastDone || "—"}</span></div>
                <div>Próxima: <span className={`${
                  overdue ? "text-red-300" : 
                  dueToday ? "text-amber-300" : "text-emerald-300"
                }`}>{t.nextDue}</span></div>
              </div>
              <div className="flex gap-2">
                <button onClick={() => onPostpone(t.id, 1)} className="px-2 py-1 rounded-lg bg-neutral-800 hover:bg-neutral-700">Aplazar +1d</button>
                <button onClick={() => onEdit(t)} className="px-2 py-1 rounded-lg bg-neutral-800 hover:bg-neutral-700">Editar</button>
                <button onClick={() => onDone(t.id)} className="px-2 py-1 rounded-lg bg-emerald-500 text-black font-medium hover:bg-emerald-400">Hecho</button>
              </div>
            </div>
          )}
        </div>
      );
    }

    function NotesSection({ notes, onCreate, onEdit, onRemove }) {
      return (
        <section className="py-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">Notas</h2>
          </div>
          {notes.length === 0 ? (
            <p className="text-neutral-400">No hay notas todavía.</p>
          ) : (
            <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-3">
              {notes.map((n) => (
                <div key={n.id} className="rounded-2xl border border-neutral-800 bg-neutral-900 p-4 flex flex-col gap-2">
                  <div className="flex items-start justify-between gap-3">
                    <div>
                      <h3 className="font-semibold">{n.title || "(Sin título)"}</h3>
                    </div>
                    <div className="flex gap-2 text-sm">
                      <button onClick={() => onEdit(n)} className="px-2 py-1 rounded-lg bg-neutral-800 hover:bg-neutral-700">Editar</button>
                      <button onClick={() => onRemove(n.id)} className="px-2 py-1 rounded-lg bg-neutral-800 hover:bg-neutral-700">Eliminar</button>
                    </div>
                  </div>
                  <div 
                    className="text-neutral-200 text-sm prose prose-invert max-w-none"
                    dangerouslySetInnerHTML={{ __html: n.content || '' }}
                  />
                </div>
              ))}
            </div>
          )}
        </section>
      );
    }

    function Stats({ tasks, historyTasks }) { // Recibir historyTasks como prop
      const tasksChartRef = useRef(null);
      const roomsChartRef = useRef(null);
      const [tasksChartInstance, setTasksChartInstance] = useState(null);
      const [roomsChartInstance, setRoomsChartInstance] = useState(null);

      const totalActiveTasks = tasks.length;
      const totalHistoryTasks = historyTasks.length;
      const overdueTasks = tasks.filter((t) => isBefore(t.nextDue, todayISO())).length;

      // Calcular la tasa de completado
      const completionRate = totalActiveTasks + totalHistoryTasks > 0
        ? (totalHistoryTasks / (totalActiveTasks + totalHistoryTasks) * 100).toFixed(1)
        : 0;

      // Estado de tareas atrasadas
      const overdueStatus = overdueTasks > 0
        ? `Tienes ${overdueTasks} tarea${overdueTasks > 1 ? 's' : ''} atrasada${overdueTasks > 1 ? 's' : ''}.`
        : "¡Todas tus tareas están al día! 🎉";

      // Datos para el gráfico de tareas completadas por mes (últimos 6 meses)
      const tasksCompletedByMonth = useMemo(() => {
        const data = {};
        const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const today = new Date();

        // Inicializar los últimos 6 meses
        for (let i = 0; i < 6; i++) {
          const d = new Date(today.getFullYear(), today.getMonth() - i, 1);
          const monthKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
          data[monthKey] = {
            label: `${monthNames[d.getMonth()]} ${d.getFullYear() % 100}`,
            count: 0
          };
        }

        historyTasks.forEach(task => {
          if (task.completedAt) {
            const date = task.completedAt.toDate();
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (data[monthKey]) {
              data[monthKey].count++;
            }
          }
        });
        
        // Convertir a array y ordenar para el gráfico
        return Object.values(data).sort((a, b) => {
          const [yearA, monthA] = a.label.split(' ')[1] ? [`20${a.label.split(' ')[1]}`, monthNames.indexOf(a.label.split(' ')[0])] : [0,0];
          const [yearB, monthB] = b.label.split(' ')[1] ? [`20${b.label.split(' ')[1]}`, monthNames.indexOf(b.label.split(' ')[0])] : [0,0];

          if (yearA !== yearB) return yearA - yearB;
          return monthA - monthB;
        });
      }, [historyTasks]);

      // Datos para el gráfico de distribución por estancia (tareas activas)
      const tasksByRoomData = useMemo(() => {
        const counts = {};
        tasks.forEach(task => {
          const room = task.room || "General";
          counts[room] = (counts[room] || 0) + 1;
        });

        const labels = Object.keys(counts);
        const data = Object.values(counts);
        const backgroundColors = [
          '#059669', '#14B8A6', '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6', '#EC4899', '#6B7280'
        ]; // Emerald, Teal, Amber, Red, Blue, Violet, Pink, Gray

        return {
          labels,
          datasets: [{
            data,
            backgroundColor: backgroundColors.slice(0, labels.length),
            hoverOffset: 4
          }]
        };
      }, [tasks]);

      // Inicializar y actualizar el gráfico de tareas completadas
      useEffect(() => {
        if (tasksChartInstance) {
          tasksChartInstance.destroy();
        }
        if (tasksChartRef.current && tasksCompletedByMonth.length > 0) {
          const ctx = tasksChartRef.current.getContext('2d');
          const newChartInstance = new Chart(ctx, {
            type: 'bar', // o 'line'
            data: {
              labels: tasksCompletedByMonth.map(d => d.label),
              datasets: [{
                label: 'Tareas completadas',
                data: tasksCompletedByMonth.map(d => d.count),
                backgroundColor: '#059669', // emerald-600
                borderColor: '#047857',
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                title: {
                  display: true,
                  text: 'Tareas completadas por mes (Últimos 6 meses)',
                  color: '#e5e7eb' // neutral-200
                }
              },
              scales: {
                x: { ticks: { color: '#a1a1aa' }, grid: { color: '#3f3f46' } }, // neutral-400, neutral-700
                y: { beginAtZero: true, ticks: { color: '#a1a1aa' }, grid: { color: '#3f3f46' } }
              }
            }
          });
          setTasksChartInstance(newChartInstance);
        }
      }, [tasksCompletedByMonth]);

      // Inicializar y actualizar el gráfico de distribución por estancia
      useEffect(() => {
        if (roomsChartInstance) {
          roomsChartInstance.destroy();
        }
        if (roomsChartRef.current && tasksByRoomData.labels.length > 0) {
          const ctx = roomsChartRef.current.getContext('2d');
          const newChartInstance = new Chart(ctx, {
            type: 'pie',
            data: tasksByRoomData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'right',
                  labels: { color: '#e5e7eb' }
                },
                title: {
                  display: true,
                  text: 'Tareas activas por estancia',
                  color: '#e5e7eb'
                }
              }
            }
          });
          setRoomsChartInstance(newChartInstance);
        }
      }, [tasksByRoomData]);


      return (
        <section className="py-6 space-y-6">
          <h2 className="text-lg font-semibold">Estadísticas</h2>
          
          <div className="grid md:grid-cols-4 gap-3"> 
            <StatCard label="Total Tareas Activas" value={totalActiveTasks} />
            <StatCard label="Historial Completado" value={totalHistoryTasks} />
            <StatCard label="Tasa de Completado" value={`${completionRate}%`} />
            <StatCard label="Estado Tareas Atrasadas" value={overdueStatus} />
          </div>
          
          <div className="grid md:grid-cols-2 gap-6">
            <div className="rounded-2xl border border-neutral-800 bg-neutral-900 p-4 h-80 flex items-center justify-center">
              <canvas ref={tasksChartRef}></canvas>
            </div>
            <div className="rounded-2xl border border-neutral-800 bg-neutral-900 p-4 h-80 flex items-center justify-center">
              <canvas ref={roomsChartRef}></canvas>
            </div>
          </div>

          <div>
            <h3 className="text-sm text-neutral-400 mb-2">Por estancia (Tareas Activas)</h3>
            <div className="grid md:grid-cols-3 gap-3">
              {Object.entries(groupBy(tasks, (t) => t.room || "General")).map(([room, list]) => (
                <StatCard key={room} label={room} value={list.length} />
              ))}
            </div>
          </div>
        </section>
      );
    }

    function StatCard({ label, value }) {
      return (
        <div className="rounded-2xl border border-neutral-800 bg-neutral-900 p-4">
          <div className="text-xs text-neutral-400">{label}</div>
          <div className="text-2xl font-semibold">{value}</div>
        </div>
      );
    }

    function BottomBar({ onCreateTask, onCreateNote, rooms }) { // Recibe rooms como prop
      return (
        <div className="fixed bottom-0 inset-x-0 z-30 border-t border-neutral-800 bg-neutral-900/95 backdrop-blur">
          <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
            <div className="text-xs text-neutral-400">Conectado a Firestore. Tus datos se guardan en la nube.</div>
            <div className="flex gap-2">
              <button onClick={onCreateTask} className="px-3 py-2 rounded-xl bg-emerald-500 text-black font-medium hover:bg-emerald-400 shadow">+ Nueva tarea</button>
              <button onClick={onCreateNote} className="px-3 py-2 rounded-xl bg-teal-500 text-black font-medium hover:bg-teal-400 shadow">+ Nueva nota</button>
            </div>
          </div>
        </div>
      );
    }

    // =====================================
    // Helpers
    // =====================================
    function groupBy(arr, keyFn) {
      return arr.reduce((acc, item) => {
        const k = keyFn(item);
        acc[k] = acc[k] || [];
        acc[k].push(item);
        return acc;
      }, {});
    }

    function formatDateHuman(iso) {
      const d = new Date(iso + "T00:00:00");
      const fmt = new Intl.DateTimeFormat("es-ES", { weekday: "long", day: "2-digit", month: "long" });
      return fmt.format(d);
    }

    // =====================================
    // Modales (Task & Note)
    // =====================================
    function openTaskModal({ task, onSave, rooms }) { // Recibe rooms aquí
      const container = document.getElementById('modal-root');
      ReactDOM.render(<TaskModal task={task} onClose={() => ReactDOM.unmountComponentAtNode(container)} onSave={onSave} rooms={rooms} />, container);
    }

    function TaskModal({ task, onClose, onSave, rooms }) { // Recibe rooms como prop
      const isNew = !task;
      const [t, setT] = useState(task || {
        title: "",
        room: "General", // Valor por defecto
        notes: "",
        frequencyType: "weekly",
        weekdays: [1],
        monthDays: [],
        intervalDays: 7,
        lastDone: todayISO(),
      });

      const toggleWeekday = (w) => {
        const set = new Set(t.weekdays || []);
        set.has(w) ? set.delete(w) : set.add(w);
        setT({ ...t, weekdays: Array.from(set).sort() });
      };
      
      const toggleMonthDay = (d) => {
        const set = new Set(t.monthDays || []);
        set.has(d) ? set.delete(d) : set.add(d);
        setT({ ...t, monthDays: Array.from(set).sort((a,b)=>a-b) });
      };

      const handleSave = async () => {
        if (!t.title.trim()) {
          showCustomAlert("Por favor, pon un título a la tarea.");
          return;
        }
        await onSave({ ...t });
        onClose();
      };

      // Opciones para el selector de estancias, excluyendo "todas" si existe
      // Esta variable ya no se usa porque volvemos a un input de texto
      // const roomOptions = useMemo(() => {
      //   return rooms.filter(r => r !== "todas").map(r => ({ value: r, label: r }));
      // }, [rooms]);


      return (
        <div className="fixed inset-0 z-40 grid place-items-center p-4 bg-black/50" onClick={onClose}>
          <div className="w-full max-w-2xl" onClick={(e) => e.stopPropagation()}>
            <div className="rounded-2xl bg-neutral-900 border border-neutral-800 shadow-xl p-4 md:p-6">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold">{isNew ? "Nueva tarea" : "Editar tarea"}</h3>
                <div className="flex gap-2">
                  <button onClick={onClose} className="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700">Cancelar</button>
                  <button onClick={handleSave} className="px-3 py-2 rounded-xl bg-emerald-500 text-black font-medium hover:bg-emerald-400">Guardar</button>
                </div>
              </div>

              <div className="grid md:grid-cols-2 gap-4">
                <div className="space-y-3">
                  <Input label="Título" value={t.title} onChange={(v) => setT({ ...t, title: v })} />
                  {/* Vuelto a Input para la estancia */}
                  <Input label="Estancia / zona" value={t.room || ""} onChange={(v) => setT({ ...t, room: v })} />
                  <Textarea label="Notas" value={t.notes || ""} onChange={(v) => setT({ ...t, notes: v })} />
                </div>
                <div className="space-y-3">
                  <Select
                    label="Tipo de frecuencia"
                    value={t.frequencyType}
                    onChange={(v) => setT({ ...t, frequencyType: v })}
                    options={[
                      { label: "Cada N días", value: "interval" },
                      { label: "Días de la semana", value: "weekly" },
                      { label: "Días del mes", value: "monthly" },
                      { label: "Días específicos (flex)", value: "specificDays" },
                      { label: "Anual", value: "yearly" }, // Nueva opción anual
                    ]}
                  />

                  {t.frequencyType === "interval" && (
                    <Input label="Cada cuántos días" type="number" min={1} value={t.intervalDays ?? 7} onChange={(v) => setT({ ...t, intervalDays: Number(v || 1) })} />
                  )}

                  {(t.frequencyType === "weekly" || t.frequencyType === "specificDays") && (
                    <div>
                      <Label>Días de la semana</Label>
                      <div className="grid grid-cols-7 gap-1 mt-1">
                        {["D", "L", "M", "X", "J", "V", "S"].map((d, i) => (
                          <button
                            key={d}
                            className={`py-1 rounded-lg border text-sm ${
                              (t.weekdays || []).includes(i)
                                ? "bg-emerald-500 border-emerald-400 text-black"
                                : "bg-neutral-800 border-neutral-700 text-neutral-300"
                            }`}
                            onClick={() => toggleWeekday(i)}
                          >
                            {d}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}

                  {(t.frequencyType === "monthly" || t.frequencyType === "specificDays") && (
                    <div>
                      <Label>Días del mes</Label>
                      <div className="grid grid-cols-7 gap-1 mt-1 max-h-40 overflow-auto pr-1">
                        {Array.from({ length: 31 }, (_, i) => i + 1).map((d) => (
                          <button
                            key={d}
                            className={`py-1 rounded-lg border text-sm ${
                              (t.monthDays || []).includes(d)
                                ? "bg-emerald-500 border-emerald-400 text-black"
                                : "bg-neutral-800 border-neutral-700 text-neutral-300"
                            }`}
                            onClick={() => toggleMonthDay(d)}
                          >
                            {d}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}

                  {t.frequencyType === "yearly" && ( // Campo para frecuencia anual
                    <p className="text-sm text-neutral-400">La tarea se repetirá anualmente a partir de la "Última vez".</p>
                  )}

                  <Input label="Última vez (YYYY-MM-DD)" type="date" value={t.lastDone || todayISO()} onChange={(v) => setT({ ...t, lastDone: v })} />
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function openNoteModal({ note, onSave }) {
      const container = document.getElementById('modal-root');
      ReactDOM.render(<NoteModal note={note} onClose={() => ReactDOM.unmountComponentAtNode(container)} onSave={onSave} />, container);
    }

    function NoteModal({ note, onClose, onSave }) {
      const isNew = !note;
      const [n, setN] = useState(note || { title: "", content: "" }); 
      const editorRef = useRef(null);

      const formatText = (command, value = null) => {
        document.execCommand(command, false, value);
        if (editorRef.current) {
          setN({ ...n, content: editorRef.current.innerHTML });
        }
      };

      const handleSave = async () => {
        if (!n.title.trim() && !n.content.trim()) {
          showCustomAlert("Por favor, escribe un título o contenido para la nota.");
          return;
        }
        await onSave({ ...n });
        onClose();
      };

      return (
        <div className="fixed inset-0 z-40 grid place-items-center p-4 bg-black/50" onClick={onClose}>
          <div className="w-full max-w-2xl" onClick={(e) => e.stopPropagation()}>
            <div className="rounded-2xl bg-neutral-900 border border-neutral-800 shadow-xl p-4 md:p-6">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold">{isNew ? "Nueva nota" : "Editar nota"}</h3>
                <div className="flex gap-2">
                  <button onClick={onClose} className="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700">Cancelar</button>
                  <button onClick={handleSave} className="px-3 py-2 rounded-xl bg-teal-500 text-black font-medium hover:bg-teal-400">Guardar</button>
                </div>
              </div>

              <Input label="Título" value={n.title} onChange={(v) => setN({ ...n, title: v })} />
              
              <div className="mt-3">
                <div className="flex justify-between items-center mb-1">
                  <Label>Contenido</Label>
                  <div className="flex gap-1 flex-wrap"> {/* Flex-wrap para botones en pantallas pequeñas */}
                    <button 
                      type="button"
                      onClick={() => formatText('bold')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Negrita"
                    >
                      <strong>B</strong>
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('italic')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Cursiva"
                    >
                      <em>I</em>
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('underline')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Subrayado"
                    >
                      <u>U</u>
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('insertUnorderedList')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Lista sin ordenar"
                    >
                      • Lista
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('insertOrderedList')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Lista ordenada"
                    >
                      1. Lista
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('justifyLeft')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Alinear a la izquierda"
                    >
                      ⬅
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('justifyCenter')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Centrar"
                    >
                      ↔
                    </button>
                    <button 
                      type="button"
                      onClick={() => formatText('justifyRight')}
                      className="px-2 py-1 rounded bg-neutral-800 hover:bg-neutral-700"
                      title="Alinear a la derecha"
                    >
                      ➡
                    </button>
                  </div>
                </div>
                <div
                  ref={editorRef}
                  contentEditable
                  dangerouslySetInnerHTML={{ __html: n.content || '' }}
                  onInput={(e) => setN({ ...n, content: e.currentTarget.innerHTML })}
                  className="w-full px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-teal-500 min-h-40 max-h-96 overflow-y-auto"
                />
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Custom Alert Modal
    function showCustomAlert(message) {
      const container = document.getElementById('modal-root');
      ReactDOM.render(
        <div className="fixed inset-0 z-50 grid place-items-center p-4 bg-black/50" onClick={() => ReactDOM.unmountComponentAtNode(container)}>
          <div className="bg-neutral-900 border border-neutral-800 rounded-2xl shadow-xl p-6 max-w-sm w-full text-center" onClick={(e) => e.stopPropagation()}>
            <h4 className="text-lg font-semibold mb-4">Aviso</h4>
            <p className="text-neutral-200 mb-6">{message}</p>
            <button
              onClick={() => ReactDOM.unmountComponentAtNode(container)}
              className="px-4 py-2 rounded-xl bg-emerald-500 text-black font-medium hover:bg-emerald-400"
            >
              Entendido
            </button>
          </div>
        </div>,
        container
      );
    }

    // Custom Confirm Modal
    function showCustomConfirm(message, details = "") {
      return new Promise((resolve) => {
        const container = document.getElementById('modal-root');
        const handleConfirm = (result) => {
          ReactDOM.unmountComponentAtNode(container);
          resolve(result);
        };

        ReactDOM.render(
          <div className="fixed inset-0 z-50 grid place-items-center p-4 bg-black/50" onClick={() => handleConfirm(false)}>
            <div className="bg-neutral-900 border border-neutral-800 rounded-2xl shadow-xl p-6 max-w-sm w-full text-center" onClick={(e) => e.stopPropagation()}>
              <h4 className="text-lg font-semibold mb-4">Confirmación</h4>
              <p className="text-neutral-200 mb-2">{message}</p>
              {details && <p className="text-neutral-400 text-sm mb-6">{details}</p>}
              <div className="flex justify-center gap-4">
                <button
                  onClick={() => handleConfirm(false)}
                  className="px-4 py-2 rounded-xl bg-neutral-800 text-neutral-100 font-medium hover:bg-neutral-700"
                >
                  Cancelar
                </button>
                <button
                  onClick={() => handleConfirm(true)}
                  className="px-4 py-2 rounded-xl bg-emerald-500 text-black font-medium hover:bg-emerald-400"
                >
                  Confirmar
                </button>
              </div>
            </div>
          </div>,
          container
        );
      });
    }

    // Reusables
    function Input({ label, value, onChange, type = "text", ...rest }) {
      return (
        <label className="block">
          <Label>{label}</Label>
          <input
            type={type}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="w-full px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500"
            {...rest}
          />
        </label>
      );
    }

    function Textarea({ label, value, onChange }) {
      return (
        <label className="block">
          <Label>{label}</Label>
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="w-full px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500 min-h-28"
          />
        </label>
      );
    }

    function Select({ label, value, onChange, options }) {
      return (
        <label className="block">
          <Label>{label}</Label>
          <select
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="w-full px-3 py-2 rounded-xl bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500"
          >
            {options.map((o) => (
              <option key={o.value} value={o.value}>{o.label}</option>
            ))}
          </select>
        </label>
      );
    }

    function Label({ children }) { return <div className="text-xs text-neutral-400 mb-1">{children}</div>; }

    // Monta la app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
