<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App de Control de Tareas del Hogar</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Reset de estilos */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Estilos generales del cuerpo */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f5f7fa;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Asegura que el body ocupe al menos el 100% de la altura de la ventana */
            margin: 0; /* Elimina márgenes por defecto */
            padding: 0; /* Elimina paddings por defecto */
        }

        /* Contenedor del "teléfono" para simular una app móvil */
        .phone-container {
            width: 90%; /* Ocupa el 90% del ancho del body */
            max-width: 375px; /* Máximo 375px de ancho (tamaño de un móvil estándar) */
            height: 90vh; /* Ocupa el 90% de la altura de la ventana */
            max-height: 812px; /* Máximo 812px de alto (tamaño de un móvil estándar) */
            aspect-ratio: 375 / 812; /* Mantiene la proporción de un teléfono móvil (ancho / alto) */
            background-color: #fff;
            border-radius: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden; /* Asegura que el contenido interno no se desborde */
            position: relative;
            display: flex; /* Usar flexbox para el layout interno */
            flex-direction: column;
        }

        /* Encabezado de la aplicación */
        .app-header {
            background-color: #4a6fa5;
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Evita que el header se encoja */
        }

        /* Título de la aplicación en el encabezado */
        .app-title {
            font-size: 24px;
            font-weight: 500;
        }

        /* Muestra de la fecha en el encabezado */
        .date-display {
            font-size: 16px;
            font-weight: 300;
        }

        /* Contenido principal de la aplicación, con scroll */
        .main-content {
            flex-grow: 1; /* Ocupa todo el espacio disponible */
            overflow-y: auto; /* Permite scroll vertical */
            padding-bottom: 20px; /* Espacio al final del scroll */
        }

        /* Sección de tareas */
        .task-section, .notes-section {
            padding: 15px;
            margin-bottom: 10px;
        }

        /* Título de cada sección de tareas/notas */
        .section-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 10px;
            color: #4a6fa5;
            display: flex;
            align-items: center;
        }

        /* Icono dentro del título de la sección */
        .section-title .material-icons {
            margin-right: 8px;
            font-size: 20px;
        }

        /* Lista de tareas */
        .task-list, .note-list {
            list-style: none;
        }

        /* Elemento individual de la tarea */
        .task-item, .note-item {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: transform 0.2s;
        }

        /* Efecto hover para las tareas/notas */
        .task-item:hover, .note-item:hover {
            transform: scale(1.01);
        }
        
        /* Borde izquierdo para tareas pendientes */
        .task-item.pending {
            border-left: 4px solid #ff9e6d;
        }
        
        /* Borde izquierdo y opacidad para tareas completadas */
        .task-item.completed {
            border-left: 4px solid #4caf50;
            opacity: 0.7;
        }
        
        /* Borde izquierdo para tareas próximas */
        .task-item.upcoming {
            border-left: 4px solid #64b5f6;
        }
        
        /* Información de la tarea (nombre y tiempo) */
        .task-info, .note-info {
            flex: 1;
            cursor: pointer; /* Permite que la info de la tarea sea clickeable para toggle */
        }
        
        /* Nombre de la tarea/título de la nota */
        .task-name, .note-title {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        /* Tiempo o frecuencia de la tarea/contenido de la nota */
        .task-time, .note-content-preview {
            font-size: 14px;
            color: #757575;
            white-space: nowrap; /* Evita que el texto se divida en varias líneas */
            overflow: hidden;     /* Oculta el contenido que excede el ancho */
            text-overflow: ellipsis; /* Añade puntos suspensivos (...) si el texto es demasiado largo */
        }
        
        /* Contenedor de iconos de estado y acciones */
        .task-actions, .note-actions {
            display: flex;
            align-items: center;
            gap: 5px; /* Espacio entre los iconos */
            flex-shrink: 0; /* Evita que los botones se encojan */
        }
        
        /* Estilo general para los iconos de estado */
        .task-status .material-icons,
        .task-actions .material-icons,
        .note-actions .material-icons {
            font-size: 20px;
            margin: 0; /* Asegura que no haya márgenes no deseados */
        }
        
        /* Color del icono para tareas pendientes */
        .task-status .pending-icon {
            color: #ff9e6d;
        }
        
        /* Color del icono para tareas completadas */
        .task-status .completed-icon {
            color: #4caf50;
        }
        
        /* Color del icono para tareas próximas */
        .task-status .upcoming-icon {
            color: #64b5f6;
        }
        
        /* Botón de acción flotante (FAB) */
        .fab-button {
            position: absolute;
            bottom: 90px; /* Ajustado para no solaparse con el nav-bar */
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #4a6fa5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
            z-index: 5; /* Asegura que esté por encima de otros elementos */
        }
        
        /* Efecto hover para el FAB */
        .fab-button:hover {
            transform: scale(1.05);
        }
        
        /* Icono dentro del FAB */
        .fab-button .material-icons {
            font-size: 30px;
        }
        
        /* Barra de navegación inferior */
        .bottom-nav {
            position: relative; /* Cambiado a relative para que el FAB no lo pise */
            height: 70px;
            background-color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            z-index: 5; /* Asegura que esté por encima de otros elementos */
            flex-shrink: 0; /* Evita que el nav se encoja */
        }
        
        /* Elemento de navegación individual */
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #757575;
            cursor: pointer;
            flex: 1; /* Permite que los items ocupen el mismo espacio */
            padding: 10px 0; /* Espacio vertical para hacerlos más clickeables */
        }
        
        /* Estilo para el elemento de navegación activo */
        .nav-item.active {
            color: #4a6fa5;
        }
        
        /* Icono del elemento de navegación */
        .nav-item .material-icons {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        /* Texto del elemento de navegación */
        .nav-item span {
            font-size: 12px;
        }

        /* Modal (general) */
        .modal {
            display: none; /* Oculto por defecto */
            position: absolute; /* Cambiado a absolute para que sea relativo al phone-container */
            z-index: 10; /* Por encima de todo */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4); /* Fondo semi-transparente */
            justify-content: center;
            align-items: center;
        }

        /* Contenido del modal */
        .modal-content {
            background-color: #fefefe;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 400px; /* Ancho máximo para el modal */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        /* Botón de cerrar del modal */
        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Efecto hover para el botón de cerrar */
        .close-button:hover,
        .close-button:focus {
            color: #333;
            text-decoration: none;
        }

        /* Título dentro del modal */
        .modal-content h2 {
            margin-bottom: 20px;
            color: #4a6fa5;
        }

        /* Estilos para inputs y selects del modal */
        .modal-content input,
        .modal-content select,
        .modal-content textarea { /* Añadido textarea */
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Roboto', sans-serif; /* Asegura la misma fuente */
        }
        .modal-content textarea {
            min-height: 80px;
            resize: vertical; /* Permite redimensionar verticalmente */
        }
        /* Estilos específicos para el input de tipo file */
        .modal-content input[type="file"] {
            border: 1px dashed #ccc; /* Borde punteado para indicar zona de archivo */
            padding: 15px;
            cursor: pointer;
            margin-bottom: 15px;
            font-size: 14px;
            color: #555;
            background-color: #f9f9f9;
        }
        .modal-content input[type="file"]::-webkit-file-upload-button {
            visibility: hidden;
            width: 0;
            padding: 0;
            margin: 0;
        }
        .modal-content input[type="file"]::before {
            content: 'Seleccionar archivo';
            display: inline-block;
            background: #4a6fa5;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 8px 12px;
            outline: none;
            white-space: nowrap;
            -webkit-user-select: none;
            cursor: pointer;
            font-size: 1em;
            margin-right: 10px;
        }
        .modal-content input[type="file"]:hover::before {
            background: #3b5b82;
        }
        .file-upload-status {
            margin-top: -8px;
            margin-bottom: 10px;
            font-size: 13px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .file-upload-status.error {
            color: #e57373;
        }
        .file-upload-status.success {
            color: #4caf50;
        }
        .existing-attachment-container {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #eee;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .existing-attachment-container a {
            color: #4a6fa5;
            text-decoration: none;
            font-weight: 500;
        }
        .existing-attachment-container a:hover {
            text-decoration: underline;
        }
        .existing-attachment-container .delete-attachment-button {
            background: none;
            border: none;
            color: #e57373;
            cursor: pointer;
            padding: 3px;
            border-radius: 50%;
        }
        .existing-attachment-container .delete-attachment-button:hover {
            background-color: rgba(229, 115, 115, 0.2);
        }



        /* Estilos para el botón de guardar del modal */
        .modal-content button {
            width: 100%;
            padding: 10px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Estilos para los botones de acción dentro de las tareas/notas */
        .task-action-button, .note-action-button {
            background: none;
            border: none;
            color: #757575; /* Color por defecto para los iconos de acción */
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .task-action-button:hover, .note-action-button:hover {
            background-color: #e0e0e0;
            color: #4a6fa5; /* Color al pasar el ratón */
        }

        .task-action-button.delete-button:hover, .note-action-button.delete-button:hover {
            color: #e57373; /* Rojo para el botón de eliminar */
        }

        .task-action-button.postpone-button:hover {
            color: #ff9e6d; /* Naranja para el botón de posponer */
        }

        .task-action-button.edit-button:hover, .note-action-button.edit-button:hover {
            color: #64b5f6; /* Azul para el botón de editar */
        }


        .task-action-button .material-icons, .note-action-button .material-icons {
            font-size: 20px;
            margin: 0;
        }

        /* Animación para el icono de carga */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        /* Estilo para el contenido del consejo en el modal */
        #tip-content {
            font-size: 16px;
            line-height: 1.5;
            color: #555;
            text-align: justify;
            min-height: 50px; /* Asegura que el contenido tenga un espacio mínimo */
        }

        /* Estilos para el dashboard */
        .dashboard-cards {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            gap: 15px; /* Espacio entre las tarjetas */
        }

        .dashboard-card {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 20px;
            flex: 1; /* Ocupa el mismo espacio */
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 140px; /* Ancho mínimo para las tarjetas */
        }

        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .dashboard-card .card-title {
            font-size: 18px;
            font-weight: 500;
            color: #4a6fa5;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dashboard-card .card-title .material-icons {
            margin-right: 8px;
            font-size: 22px;
        }

        .dashboard-card .card-count {
            font-size: 36px;
            font-weight: 700;
            color: #333;
        }

        /* Estilos para el modal de confirmación de eliminación */
        .confirm-modal-buttons {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin-top: 20px;
        }

        .confirm-modal-buttons button {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .confirm-modal-buttons .confirm-delete-button {
            background-color: #e57373; /* Rojo para confirmar */
            color: white;
            border: none;
        }

        .confirm-modal-buttons .cancel-delete-button {
            background-color: #f0f0f0; /* Gris claro para cancelar */
            color: #333;
            border: 1px solid #ddd;
        }

        .confirm-modal-buttons button:hover {
            opacity: 0.9;
        }

        /* Estilos para el campo de búsqueda de notas */
        .notes-search-container {
            padding: 15px;
            background-color: #f0f2f5;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .notes-search-container input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px; /* Bordes redondeados para el campo de búsqueda */
            font-size: 16px;
            background-color: white;
        }
        .notes-search-container button {
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .notes-search-container button .material-icons {
            font-size: 20px;
        }

    </style>
</head>
<body>
    <div class="phone-container">
        <div class="app-header">
            <div class="app-title">Mi Hogar Ordenado</div>
            <div class="date-display" id="date-display"></div>
        </div>
        
        <div class="main-content" id="main-content-area">
            <!-- Vistas de la aplicación -->
            <div id="dashboard-view" style="display: block;">
                <div class="dashboard-cards">
                    <div class="dashboard-card" id="today-tasks-card">
                        <div class="card-title"><i class="material-icons">today</i> Tareas de Hoy</div>
                        <div class="card-count" id="today-task-count">0</div>
                    </div>
                    <div class="dashboard-card" id="pending-tasks-card">
                        <div class="card-title"><i class="material-icons">schedule</i> Pendientes</div>
                        <div class="card-count" id="pending-task-count">0</div>
                    </div>
                </div>
                <div id="current-tasks-list">
                    <!-- Las secciones de tareas se renderizarán aquí dinámicamente mediante JavaScript -->
                </div>
            </div>

            <div id="history-view" style="display: none;">
                <div class="task-section">
                    <div class="section-title">
                        <i class="material-icons">history</i> Historial de Tareas
                    </div>
                    <ul class="task-list" id="history-task-list">
                        <!-- Las tareas completadas se renderizarán aquí -->
                    </ul>
                </div>
            </div>

            <!-- Nueva sección de Notas -->
            <div id="notes-view" style="display: none;">
                <div class="notes-search-container">
                    <input type="text" id="note-search-input" placeholder="Buscar notas...">
                    <button id="add-note-button">
                        <i class="material-icons">add</i> Nueva Nota
                    </button>
                </div>
                <div class="notes-section">
                    <div class="section-title">
                        <i class="material-icons">article</i> Mis Notas
                    </div>
                    <ul class="note-list" id="notes-list">
                        <!-- Las notas se renderizarán aquí dinámicamente -->
                    </ul>
                </div>
            </div>

        </div>

        <!-- Botón flotante para añadir tareas -->
        <div class="fab-button" id="fab-button">
            <i class="material-icons">add</i>
        </div>
        
        <!-- Barra de navegación inferior -->
        <div class="bottom-nav">
            <div class="nav-item active" id="nav-home">
                <i class="material-icons">home</i>
                <span>Inicio</span>
            </div>
            <div class="nav-item" id="nav-notes">
                <i class="material-icons">article</i>
                <span>Notas</span>
            </div>
            <div class="nav-item" id="nav-calendar">
                <i class="material-icons">calendar_today</i>
                <span>Calendario</span>
            </div>
            <div class="nav-item" id="nav-history">
                <i class="material-icons">history</i>
                <span>Historial</span>
            </div>
        </div>

        <!-- Modal para añadir/editar tareas -->
        <div id="taskModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeTaskModal">&times;</span>
                <h2 id="taskModalTitle">Añadir Nueva Tarea</h2>
                <input type="hidden" id="task-id-input"> <!-- Campo oculto para el ID de la tarea a editar -->
                <input type="text" id="task-name-input" placeholder="Nombre de la tarea" required>
                <select id="task-area-select">
                    <option value="Cocina">Cocina</option>
                    <option value="Baños">Baños</option>
                    <option value="Dormitorios">Dormitorios</option>
                    <option value="General">General</option>
                </select>
                <select id="task-frequency-select">
                    <option value="Diario">Diario</option>
                    <option value="Semanal">Semanal</option>
                    <option value="Mensual">Mensual</option>
                </select>
                <!-- Campo para la fecha de vencimiento -->
                <input type="date" id="task-due-date-input">
                <button id="save-task-button">Guardar Tarea</button>
            </div>
        </div>

        <!-- Modal para mostrar consejos de limpieza -->
        <div id="tipModal" class="modal">
            <div class="modal-content">
                <span class="close-button tip-close-button">&times;</span>
                <h2>Consejo de Limpieza ✨</h2>
                <p id="tip-content">Generando consejo...</p>
                <div id="tip-loading" style="display: none; text-align: center; margin-top: 15px;">
                    <i class="material-icons spin" style="font-size: 24px; color: #4a6fa5;">cached</i>
                </div>
            </div>
        </div>

        <!-- Modal de Confirmación de Eliminación (General para Tareas y Notas) -->
        <div id="confirmDeleteModal" class="modal">
            <div class="modal-content">
                <h2>Confirmar Eliminación</h2>
                <p id="confirm-delete-message">¿Estás seguro de que quieres eliminar este elemento?</p>
                <div class="confirm-modal-buttons">
                    <button class="confirm-delete-button" id="confirm-delete-yes">Sí, Eliminar</button>
                    <button class="cancel-delete-button" id="confirm-delete-no">No, Cancelar</button>
                </div>
            </div>
        </div>

        <!-- Nuevo Modal para añadir/editar notas -->
        <div id="noteModal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="closeNoteModal">&times;</span>
                <h2 id="noteModalTitle">Nueva Nota</h2>
                <input type="hidden" id="note-id-input">
                <input type="text" id="note-title-input" placeholder="Título de la nota" required>
                <textarea id="note-content-input" placeholder="Contenido de la nota (puedes pegar enlaces o texto largo aquí)"></textarea>
                <!-- Campo para adjuntar archivo -->
                <input type="file" id="note-attachment-input" accept="image/*, application/pdf, .txt, .doc, .docx, .xls, .xlsx">
                <div id="file-upload-status" class="file-upload-status" style="display:none;"></div>
                <div id="existing-attachment-display" class="existing-attachment-container" style="display:none;">
                    <a id="existing-attachment-link" href="#" target="_blank"></a>
                    <button class="delete-attachment-button" title="Eliminar archivo adjunto"><i class="material-icons">close</i></button>
                </div>
                <button id="save-note-button">Guardar Nota</button>
            </div>
        </div>

    </div>
    
    <!-- Incluye el SDK de Firebase -->
    <script type="module">
        // Importa las funciones necesarias de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { getFirestore, collection, getDocs, addDoc, doc, updateDoc, deleteDoc, query, where, getDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        // Importa las funciones de Firebase Storage
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-storage.js";


        // Firebase Config (obtenida del entorno de Canvas)
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        // App ID (obtenido del entorno de Canvas)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Inicializa Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const storage = getStorage(app); // Inicializa Firebase Storage

        let currentUserId = null; // Para almacenar el ID del usuario autenticado

        // Autenticación anónima o con token (proporcionado por Canvas)
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                console.log("Usuario autenticado:", currentUserId);
                // Una vez autenticado, cargar las tareas
                fetchAndRenderTasks('all');
                renderDashboardCounts();
            } else {
                console.log("Iniciando sesión anónimamente...");
                try {
                    if (typeof __initial_auth_token !== 'undefined') {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Error al iniciar sesión:", error);
                }
            }
        });

        // Obtener referencias a elementos del DOM
        const mainContentArea = document.getElementById('main-content-area');
        const dashboardView = document.getElementById('dashboard-view');
        const historyView = document.getElementById('history-view');
        const notesView = document.getElementById('notes-view'); // Nueva vista de notas
        const currentTasksList = document.getElementById('current-tasks-list');
        const historyTaskList = document.getElementById('history-task-list');
        const notesList = document.getElementById('notes-list'); // Lista de notas

        const fabButton = document.getElementById('fab-button');
        const taskModal = document.getElementById('taskModal');
        const closeTaskModalButton = document.getElementById('closeTaskModal');
        const taskModalTitle = document.getElementById('taskModalTitle');
        const taskIdInput = document.getElementById('task-id-input'); // Para editar
        const taskNameInput = document.getElementById('task-name-input');
        const taskAreaSelect = document.getElementById('task-area-select');
        const taskFrequencySelect = document.getElementById('task-frequency-select');
        const taskDueDateInput = document.getElementById('task-due-date-input'); // Nuevo campo de fecha
        const saveTaskButton = document.getElementById('save-task-button');
        
        const dateDisplay = document.getElementById('date-display');

        // Elementos del dashboard
        const todayTasksCard = document.getElementById('today-tasks-card');
        const pendingTasksCard = document.getElementById('pending-tasks-card');
        const todayTaskCount = document.getElementById('today-task-count');
        const pendingTaskCount = document.getElementById('pending-task-count');

        // Elementos del modal de consejos
        const tipModal = document.getElementById('tipModal');
        const tipCloseButton = document.querySelector('.tip-close-button');
        const tipContent = document.getElementById('tip-content');
        const tipLoading = document.getElementById('tip-loading');

        // Elementos del modal de confirmación de eliminación
        const confirmDeleteModal = document.getElementById('confirmDeleteModal');
        const confirmDeleteMessage = document.getElementById('confirm-delete-message');
        const confirmDeleteYesButton = document.getElementById('confirm-delete-yes');
        const confirmDeleteNoButton = document.getElementById('confirm-delete-no');
        let itemToDeleteId = null; // Variable para almacenar el ID de la tarea/nota a eliminar
        let itemToDeleteType = null; // Variable para almacenar el tipo ('task' o 'note')
        let itemToDeleteAttachmentPath = null; // Para almacenar la ruta del archivo a eliminar en Storage

        // Elementos del nuevo modal de notas
        const noteModal = document.getElementById('noteModal');
        const closeNoteModalButton = document.getElementById('closeNoteModal');
        const noteModalTitle = document.getElementById('noteModalTitle');
        const noteIdInput = document.getElementById('note-id-input');
        const noteTitleInput = document.getElementById('note-title-input');
        const noteContentInput = document.getElementById('note-content-input');
        const noteAttachmentInput = document.getElementById('note-attachment-input'); // Input de archivo
        const fileUploadStatus = document.getElementById('file-upload-status'); // Estado de la subida
        const existingAttachmentDisplay = document.getElementById('existing-attachment-display'); // Contenedor para adjunto existente
        const existingAttachmentLink = document.getElementById('existing-attachment-link'); // Enlace al adjunto existente
        const deleteAttachmentButton = existingAttachmentDisplay.querySelector('.delete-attachment-button'); // Botón para eliminar adjunto existente
        const saveNoteButton = document.getElementById('save-note-button');
        const addNoteButton = document.getElementById('add-note-button'); // Botón para añadir nota en vista de notas
        const noteSearchInput = document.getElementById('note-search-input'); // Campo de búsqueda de notas

        // Navegación
        const navHome = document.getElementById('nav-home');
        const navNotes = document.getElementById('nav-notes'); // Renombrado de nav-zones
        const navCalendar = document.getElementById('nav-calendar');
        const navHistory = document.getElementById('nav-history');

        let currentView = 'home'; // Controla la vista actual (home, notes, history, etc.)

        // Configuración de la API de Gemini
        const GEMINI_API_KEY = ""; // Esta clave será proporcionada por el entorno de Canvas/Vercel
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;

        /**
         * Retorna el icono de Material Design basado en el estado de la tarea.
         * @param {string} status - El estado de la tarea ("pending", "completed", "upcoming").
         * @returns {string} El nombre del icono de Material Design.
         */
        const getIconForStatus = (status) => {
            switch (status) {
                case 'pending': return 'schedule'; // Icono de reloj para pendiente
                case 'completed': return 'check_circle'; // Icono de verificación para completado
                case 'upcoming': return 'event'; // Icono de calendario para próximo
                default: return ''; // Por si acaso
            }
        };

        /**
         * Retorna el icono de Material Design basado en el área de la tarea.
         * @param {string} area - El área de la tarea ("Cocina", "Baños", "Dormitorios", etc.).
         * @returns {string} El nombre del icono de Material Design.
         */
        const getIconForArea = (area) => {
            switch (area) {
                case 'Cocina': return 'kitchen';
                case 'Baños': return 'bathtub';
                case 'Dormitorios': return 'bed';
                case 'General': return 'home'; // Un icono general para tareas que no encajan en una categoría específica
                default: return '';
            }
        };

        /**
         * Función auxiliar para obtener la referencia a la colección de tareas del usuario.
         * @returns {import("firebase/firestore").CollectionReference} La referencia a la colección de tareas.
         */
        const getTasksCollectionRef = () => {
            if (!currentUserId) {
                console.error("No hay usuario autenticado para acceder a las tareas.");
                return collection(db, `artifacts/${appId}/users/anonymous/tasks`);
            }
            return collection(db, `artifacts/${appId}/users/${currentUserId}/tasks`);
        };

        /**
         * Función auxiliar para obtener la referencia a la colección de notas del usuario.
         * @returns {import("firebase/firestore").CollectionReference} La referencia a la colección de notas.
         */
        const getNotesCollectionRef = () => {
            if (!currentUserId) {
                console.error("No hay usuario autenticado para acceder a las notas.");
                return collection(db, `artifacts/${appId}/users/anonymous/notes`);
            }
            return collection(db, `artifacts/${appId}/users/${currentUserId}/notes`);
        };

        /**
         * Función auxiliar para realizar llamadas fetch con reintentos y retroceso exponencial.
         * Útil para manejar problemas temporales de red o límites de tasa de API.
         */
        const retryFetch = async (url, options, retries = 3, delay = 1000) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Si es un error 429 (Too Many Requests) y quedan reintentos
                        if (response.status === 429 && i < retries - 1) {
                            await new Promise(res => setTimeout(res, delay * (2 ** i)));
                            continue; // Reintentar
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    console.error(`Intento de fetch ${i + 1} falló:`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay * (2 ** i)));
                    } else {
                        throw error; // Lanzar el error si no quedan reintentos
                    }
                }
            }
        };

        /**
         * Genera un consejo de limpieza utilizando la API de Gemini.
         * @param {string} taskName - El nombre de la tarea para la que se quiere el consejo.
         * @returns {string} El consejo de limpieza generado por el LLM o un mensaje de error.
         */
        const generateCleaningTip = async (taskName) => {
            const prompt = `Dame un consejo de limpieza rápido y eficaz para la tarea: "${taskName}". Sé conciso y directo, no incluyas el nombre de la tarea en la respuesta. Maximo 100 caracteres.`;
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };

            try {
                const response = await retryFetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Respuesta inesperada de la API de Gemini:", result);
                    return "No se pudo generar el consejo en este momento. Inténtalo de nuevo más tarde.";
                }
            } catch (error) {
                console.error("Error al llamar a la API de Gemini:", error);
                return "Hubo un problema al conectar con el servicio de IA. Inténtalo de nuevo.";
            }
        };

        /**
         * Renderiza el recuento de tareas en las tarjetas del dashboard.
         */
        const renderDashboardCounts = async () => {
            if (!currentUserId) return;

            const tasksRef = getTasksCollectionRef();
            const querySnapshot = await getDocs(tasksRef);
            const tasks = [];
            querySnapshot.forEach((doc) => {
                tasks.push({ id: doc.id, ...doc.data() });
            });

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let todayCount = 0;
            let pendingCount = 0;

            tasks.forEach(task => {
                if (task.dueDate) {
                    const dueDate = new Date(task.dueDate);
                    dueDate.setHours(0, 0, 0, 0);
                    if (dueDate.getTime() === today.getTime() && task.status !== 'completed') {
                        todayCount++;
                    }
                }
                if (task.status === 'pending') {
                    pendingCount++;
                }
            });

            todayTaskCount.textContent = todayCount;
            pendingTaskCount.textContent = pendingCount;
        };

        /**
         * Función asincrónica para obtener las tareas de Firestore y renderizarlas en la interfaz.
         * @param {string} filterType - Tipo de filtro: 'all', 'today', 'pending', 'completed'.
         */
        const fetchAndRenderTasks = async (filterType = 'all') => {
            if (!currentUserId) return;

            currentTasksList.innerHTML = ''; // Limpiar el contenedor de tareas existentes
            historyTaskList.innerHTML = ''; // Limpiar el contenedor de historial
            
            const tasksRef = getTasksCollectionRef();
            let tasksQuery;

            if (filterType === 'completed') {
                tasksQuery = query(tasksRef, where("status", "==", "completed"));
            } else if (filterType === 'pending') {
                 tasksQuery = query(tasksRef, where("status", "==", "pending"));
            } else if (filterType === 'today') {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);

                tasksQuery = query(
                    tasksRef,
                    where("dueDate", ">=", today.toISOString().split('T')[0]),
                    where("dueDate", "<", tomorrow.toISOString().split('T')[0])
                );
            } else {
                tasksQuery = tasksRef;
            }

            const querySnapshot = await getDocs(tasksQuery);
            let tasks = [];
            querySnapshot.forEach((doc) => {
                tasks.push({ id: doc.id, ...doc.data() });
            });

            if (filterType === 'today') {
                tasks = tasks.filter(task => task.status !== 'completed');
            }

            tasks.sort((a, b) => {
                if (a.status === 'completed' && b.status !== 'completed') return 1;
                if (a.status !== 'completed' && b.status === 'completed') return -1;
                return 0;
            });

            const groupedTasks = tasks.reduce((acc, task) => {
                const area = task.area;
                if (!acc[area]) {
                    acc[area] = [];
                }
                acc[area].push(task);
                return acc;
            }, {});

            if (filterType === 'completed') {
                tasks.forEach(task => {
                    const taskItem = createTaskItemHTML(task);
                    historyTaskList.appendChild(taskItem);
                });
            } else {
                for (const area in groupedTasks) {
                    const section = document.createElement('div');
                    section.className = 'task-section';
                    section.innerHTML = `
                        <div class="section-title">
                            <i class="material-icons">${getIconForArea(area)}</i>
                            ${area}
                        </div>
                        <ul class="task-list" id="task-list-${area.replace(/\s+/g, '-') /* Sanitiza el ID */}"></ul>
                    `;
                    currentTasksList.appendChild(section);

                    const taskList = document.getElementById(`task-list-${area.replace(/\s+/g, '-')}`);
                    groupedTasks[area].forEach(task => {
                        const taskItem = createTaskItemHTML(task);
                        taskList.appendChild(taskItem);
                    });
                }
            }

            attachTaskItemListeners();
        };

        /**
         * Crea el HTML para un elemento de tarea.
         * @param {Object} task - Objeto de la tarea con sus propiedades.
         * @returns {HTMLElement} El elemento LI HTML de la tarea.
         */
        const createTaskItemHTML = (task) => {
            const taskItem = document.createElement('li');
            taskItem.className = `task-item ${task.status}`;
            taskItem.dataset.id = task.id;
            taskItem.innerHTML = `
                <div class="task-info">
                    <div class="task-name">${task.name}</div>
                    <div class="task-time">${task.frequency} ${task.dueDate ? `(Vence: ${new Date(task.dueDate).toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })})` : ''}</div>
                </div>
                <div class="task-actions">
                    <button class="task-action-button tip-button" data-task-name="${task.name}" title="Obtener consejo de limpieza">
                        <i class="material-icons">lightbulb_outline</i>
                    </button>
                    ${task.status !== 'completed' ? `
                        <button class="task-action-button postpone-button" data-id="${task.id}" title="Posponer tarea">
                            <i class="material-icons">event_note</i>
                        </button>
                        <button class="task-action-button edit-button" data-id="${task.id}" title="Editar tarea">
                            <i class="material-icons">edit</i>
                        </button>
                    ` : ''}
                    <button class="task-action-button delete-button" data-id="${task.id}" data-type="task" title="Eliminar tarea">
                        <i class="material-icons">delete</i>
                    </button>
                </div>
            `;

            taskItem.querySelector('.task-info').addEventListener('click', async () => {
                const taskId = taskItem.dataset.id;
                const currentStatus = taskItem.classList.contains('pending') ? 'pending' : 'completed';
                const newStatus = currentStatus === 'pending' ? 'completed' : 'pending';
                const taskRef = doc(getTasksCollectionRef(), taskId);
                await updateDoc(taskRef, {
                    status: newStatus
                });
                fetchAndRenderTasks(currentView === 'home' ? 'all' : currentView);
                renderDashboardCounts();
            });

            return taskItem;
        };

        /**
         * Adjunta los listeners de eventos a los botones de acción de las tareas.
         */
        const attachTaskItemListeners = () => {
            document.querySelectorAll('.tip-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    const taskName = e.currentTarget.dataset.taskName;
                    
                    tipContent.textContent = "Generando consejo...";
                    tipLoading.style.display = 'block';
                    tipModal.style.display = 'flex';

                    try {
                        const tip = await generateCleaningTip(taskName);
                        tipContent.textContent = tip;
                    } finally {
                        tipLoading.style.display = 'none';
                    }
                };
            });

            document.querySelectorAll('.postpone-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    const taskId = e.currentTarget.dataset.id;
                    await postponeTask(taskId);
                };
            });

            document.querySelectorAll('.edit-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    const taskId = e.currentTarget.dataset.id;
                    await showTaskModalForEdit(taskId);
                };
            });

            document.querySelectorAll('.delete-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    itemToDeleteId = e.currentTarget.dataset.id;
                    itemToDeleteType = e.currentTarget.dataset.type; // 'task' o 'note'
                    confirmDeleteMessage.textContent = `¿Estás seguro de que quieres eliminar esta ${itemToDeleteType === 'task' ? 'tarea' : 'nota'}?`;
                    confirmDeleteModal.style.display = 'flex';
                };
            });
        };

        /**
         * Maneja la lógica para posponer una tarea.
         * Cambia la fecha de vencimiento al día siguiente y el estado a 'upcoming' si estaba 'pending'.
         * @param {string} taskId - ID de la tarea a posponer.
         */
        const postponeTask = async (taskId) => {
            const taskRef = doc(getTasksCollectionRef(), taskId);
            const taskDocSnap = await getDoc(taskRef);
            const taskData = taskDocSnap.data();

            if (taskData) {
                const today = new Date();
                today.setDate(today.getDate() + 1);
                const newDueDate = today.toISOString().split('T')[0];

                await updateDoc(taskRef, {
                    dueDate: newDueDate,
                    status: 'upcoming'
                });
                fetchAndRenderTasks(currentView === 'home' ? 'all' : currentView);
                renderDashboardCounts();
            }
        };

        /**
         * Muestra el modal de tarea con los datos precargados para edición.
         * @param {string} taskId - ID de la tarea a editar.
         */
        const showTaskModalForEdit = async (taskId) => {
            const taskRef = doc(getTasksCollectionRef(), taskId);
            const taskDocSnap = await getDoc(taskRef);
            const taskData = taskDocSnap.data();

            if (taskData) {
                taskModalTitle.textContent = 'Editar Tarea';
                taskIdInput.value = taskId;
                taskNameInput.value = taskData.name;
                taskAreaSelect.value = taskData.area;
                taskFrequencySelect.value = taskData.frequency;
                taskDueDateInput.value = taskData.dueDate || '';
                taskModal.style.display = 'flex';
            }
        };

        /**
         * Maneja la lógica para eliminar una tarea o nota.
         * @param {string} id - ID del elemento a eliminar.
         * @param {string} type - Tipo de elemento ('task' o 'note').
         */
        const deleteItem = async (id, type) => {
            if (!id || !type) return;

            try {
                if (type === 'task') {
                    await deleteDoc(doc(getTasksCollectionRef(), id));
                    console.log("Tarea eliminada:", id);
                    fetchAndRenderTasks(currentView === 'home' ? 'all' : currentView);
                    renderDashboardCounts();
                } else if (type === 'note') {
                    // Obtener la nota para ver si tiene adjuntos
                    const noteRef = doc(getNotesCollectionRef(), id);
                    const noteDoc = await getDoc(noteRef);
                    const noteData = noteDoc.data();

                    if (noteData && noteData.attachmentPath) {
                        // Eliminar archivo de Storage si existe
                        const fileRef = ref(storage, noteData.attachmentPath);
                        await deleteObject(fileRef);
                        console.log("Archivo adjunto eliminado de Storage:", noteData.attachmentPath);
                    }
                    await deleteDoc(noteRef);
                    console.log("Nota eliminada:", id);
                    fetchAndRenderNotes(); // Re-renderizar notas después de eliminar
                }
            } catch (error) {
                console.error(`Error al eliminar ${type}:`, error);
            } finally {
                itemToDeleteId = null;
                itemToDeleteType = null;
            }
        };

        // Funciones para la gestión de Notas
        /**
         * Crea el HTML para un elemento de nota.
         * @param {Object} note - Objeto de la nota con sus propiedades.
         * @returns {HTMLElement} El elemento LI HTML de la nota.
         */
        const createNoteItemHTML = (note) => {
            const noteItem = document.createElement('li');
            noteItem.className = 'note-item';
            noteItem.dataset.id = note.id;
            noteItem.innerHTML = `
                <div class="note-info">
                    <div class="note-title">${note.title}</div>
                    <div class="note-content-preview">
                        ${note.content.substring(0, 100)}${note.content.length > 100 ? '...' : ''}
                        ${note.attachmentName ? `<br><i class="material-icons" style="font-size:16px;vertical-align:middle;">attach_file</i> ${note.attachmentName}` : ''}
                    </div>
                </div>
                <div class="note-actions">
                    <button class="note-action-button edit-button" data-id="${note.id}" title="Editar nota">
                        <i class="material-icons">edit</i>
                    </button>
                    <button class="note-action-button delete-button" data-id="${note.id}" data-type="note" title="Eliminar nota">
                        <i class="material-icons">delete</i>
                    </button>
                </div>
            `;
            // Listener para ver el contenido completo de la nota
            noteItem.querySelector('.note-info').addEventListener('click', () => {
                showNoteModalForEdit(note.id); // Reutilizar la función de edición para ver/editar
            });
            return noteItem;
        };

        /**
         * Función asincrónica para obtener las notas de Firestore y renderizarlas.
         * @param {string} searchTerm - Término de búsqueda para filtrar las notas.
         */
        const fetchAndRenderNotes = async (searchTerm = '') => {
            if (!currentUserId) return;

            notesList.innerHTML = ''; // Limpiar la lista de notas
            const notesRef = getNotesCollectionRef();
            const querySnapshot = await getDocs(notesRef);
            let notes = [];
            querySnapshot.forEach((doc) => {
                notes.push({ id: doc.id, ...doc.data() });
            });

            // Filtrar notas si hay un término de búsqueda
            if (searchTerm) {
                const lowerCaseSearchTerm = searchTerm.toLowerCase();
                notes = notes.filter(note => 
                    note.title.toLowerCase().includes(lowerCaseSearchTerm) ||
                    (note.content && note.content.toLowerCase().includes(lowerCaseSearchTerm))
                );
            }

            notes.forEach(note => {
                const noteItem = createNoteItemHTML(note);
                notesList.appendChild(noteItem);
            });

            attachNoteItemListeners();
        };

        /**
         * Adjunta los listeners de eventos a los botones de acción de las notas.
         */
        const attachNoteItemListeners = () => {
            document.querySelectorAll('.note-action-button.edit-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    const noteId = e.currentTarget.dataset.id;
                    await showNoteModalForEdit(noteId);
                };
            });

            document.querySelectorAll('.note-action-button.delete-button').forEach(button => {
                button.onclick = async (e) => {
                    e.stopPropagation();
                    itemToDeleteId = e.currentTarget.dataset.id;
                    itemToDeleteType = e.currentTarget.dataset.type; // Debería ser 'note'
                    confirmDeleteMessage.textContent = `¿Estás seguro de que quieres eliminar esta nota?`;
                    confirmDeleteModal.style.display = 'flex';
                };
            });
        };

        /**
         * Muestra el modal de notas con los datos precargados para edición o para ver.
         * @param {string} noteId - ID de la nota a editar.
         */
        const showNoteModalForEdit = async (noteId) => {
            const noteRef = doc(getNotesCollectionRef(), noteId);
            const noteDocSnap = await getDoc(noteRef);
            const noteData = noteDocSnap.data();

            if (noteData) {
                noteModalTitle.textContent = 'Editar Nota';
                noteIdInput.value = noteId;
                noteTitleInput.value = noteData.title;
                noteContentInput.value = noteData.content || '';

                // Mostrar/ocultar y rellenar información del adjunto existente
                if (noteData.attachmentName && noteData.attachmentURL) {
                    existingAttachmentLink.textContent = noteData.attachmentName;
                    existingAttachmentLink.href = noteData.attachmentURL;
                    existingAttachmentDisplay.style.display = 'flex';
                } else {
                    existingAttachmentDisplay.style.display = 'none';
                    existingAttachmentLink.textContent = '';
                    existingAttachmentLink.href = '#';
                }

                fileUploadStatus.style.display = 'none'; // Ocultar estado de subida anterior
                noteAttachmentInput.value = ''; // Limpiar el input de archivo al abrir el modal
                noteModal.style.display = 'flex';
            }
        };

        // Event listeners de navegación
        navHome.addEventListener('click', () => {
            currentView = 'home';
            dashboardView.style.display = 'block';
            historyView.style.display = 'none';
            notesView.style.display = 'none';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            navHome.classList.add('active');
            fabButton.style.display = 'flex'; // Mostrar FAB en vista de inicio
            fetchAndRenderTasks('all');
            renderDashboardCounts();
        });

        navNotes.addEventListener('click', () => {
            currentView = 'notes';
            dashboardView.style.display = 'none';
            historyView.style.display = 'none';
            notesView.style.display = 'block';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            navNotes.classList.add('active');
            fabButton.style.display = 'none'; // Ocultar FAB en vista de notas (usaremos el botón interno)
            fetchAndRenderNotes(); // Cargar todas las notas
        });

        navCalendar.addEventListener('click', () => {
            console.log("Navegación a Calendario");
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            navCalendar.classList.add('active');
            currentView = 'calendar';
            dashboardView.style.display = 'block'; // Ocultar otras vistas
            historyView.style.display = 'none';
            notesView.style.display = 'none';
            fabButton.style.display = 'flex';
            fetchAndRenderTasks('all'); 
            renderDashboardCounts();
        });

        navHistory.addEventListener('click', () => {
            currentView = 'history';
            dashboardView.style.display = 'none';
            historyView.style.display = 'block';
            notesView.style.display = 'none';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            navHistory.classList.add('active');
            fabButton.style.display = 'none'; // Ocultar FAB en historial
            fetchAndRenderTasks('completed');
        });

        // Event listener para el botón FAB (Añadir Tarea)
        fabButton.addEventListener('click', () => {
            taskModalTitle.textContent = 'Añadir Nueva Tarea';
            taskIdInput.value = ''; // Limpiar ID para asegurarse de que es una nueva tarea
            taskNameInput.value = '';
            taskAreaSelect.value = 'Cocina'; // Valor por defecto
            taskFrequencySelect.value = 'Diario'; // Valor por defecto
            taskDueDateInput.value = new Date().toISOString().split('T')[0]; // Fecha por defecto: hoy
            taskModal.style.display = 'flex';
        });

        // Event listener para cerrar el modal de añadir/editar tarea
        closeTaskModalButton.addEventListener('click', () => {
            taskModal.style.display = 'none';
        });

        // Event listener para guardar la tarea (Añadir o Editar)
        saveTaskButton.addEventListener('click', async () => {
            const taskId = taskIdInput.value;
            const taskName = taskNameInput.value;
            const taskArea = taskAreaSelect.value;
            const taskFrequency = taskFrequencySelect.value;
            const selectedDueDate = taskDueDateInput.value;

            if (!taskName) {
                console.error("El nombre de la tarea no puede estar vacío.");
                return;
            }

            const dueDateToSave = selectedDueDate || new Date().toISOString().split('T')[0];

            if (taskId) {
                const taskRef = doc(getTasksCollectionRef(), taskId);
                await updateDoc(taskRef, {
                    name: taskName,
                    area: taskArea,
                    frequency: taskFrequency,
                    dueDate: dueDateToSave
                });
            } else {
                await addDoc(getTasksCollectionRef(), {
                    name: taskName,
                    area: taskArea,
                    frequency: taskFrequency,
                    status: 'pending',
                    createdAt: new Date().toISOString(),
                    dueDate: dueDateToSave
                });
            }
            taskModal.style.display = 'none';
            fetchAndRenderTasks(currentView === 'home' ? 'all' : currentView);
            renderDashboardCounts();
        });

        // Event listener para cerrar el modal de consejos
        tipCloseButton.addEventListener('click', () => {
            tipModal.style.display = 'none';
        });

        // Event listeners para las tarjetas del dashboard
        todayTasksCard.addEventListener('click', () => {
            fetchAndRenderTasks('today');
            console.log("Mostrando tareas de hoy");
        });

        pendingTasksCard.addEventListener('click', () => {
            fetchAndRenderTasks('pending');
            console.log("Mostrando tareas pendientes");
        });

        // Event listeners para el modal de confirmación de eliminación (general)
        confirmDeleteYesButton.addEventListener('click', async () => {
            await deleteItem(itemToDeleteId, itemToDeleteType);
            confirmDeleteModal.style.display = 'none';
        });

        confirmDeleteNoButton.addEventListener('click', () => {
            itemToDeleteId = null;
            itemToDeleteType = null;
            confirmDeleteModal.style.display = 'none';
        });

        // Event listener para el botón "Nueva Nota"
        addNoteButton.addEventListener('click', () => {
            noteModalTitle.textContent = 'Nueva Nota';
            noteIdInput.value = '';
            noteTitleInput.value = '';
            noteContentInput.value = '';
            noteAttachmentInput.value = ''; // Limpiar el input de archivo
            fileUploadStatus.style.display = 'none'; // Ocultar estado de subida
            existingAttachmentDisplay.style.display = 'none'; // Ocultar adjunto existente
            noteModal.style.display = 'flex';
        });

        // Event listener para cerrar el modal de notas
        closeNoteModalButton.addEventListener('click', () => {
            noteModal.style.display = 'none';
        });

        // Event listener para guardar la nota (Añadir o Editar)
        saveNoteButton.addEventListener('click', async () => {
            const noteId = noteIdInput.value;
            const noteTitle = noteTitleInput.value;
            const noteContent = noteContentInput.value;
            const file = noteAttachmentInput.files[0]; // Obtener el archivo seleccionado

            if (!noteTitle) {
                console.error("El título de la nota no puede estar vacío.");
                return;
            }

            let attachmentURL = null;
            let attachmentPath = null;
            let attachmentName = null;

            fileUploadStatus.style.display = 'block';
            fileUploadStatus.textContent = 'Subiendo archivo...';
            fileUploadStatus.classList.remove('error', 'success');

            try {
                if (file) {
                    // Si hay un archivo nuevo, lo subimos
                    const fileName = `${Date.now()}_${file.name}`;
                    const storageRef = ref(storage, `artifacts/${appId}/users/${currentUserId}/notes/${noteId || 'temp'}/${fileName}`); // Usar ID de nota si existe, sino temp
                    const uploadTask = await uploadBytes(storageRef, file);
                    attachmentURL = await getDownloadURL(uploadTask.ref);
                    attachmentPath = storageRef.fullPath;
                    attachmentName = file.name;
                    fileUploadStatus.textContent = `Archivo '${attachmentName}' subido.`;
                    fileUploadStatus.classList.add('success');
                } else if (noteId) {
                    // Si estamos editando y no hay un nuevo archivo, mantener el existente
                    const noteRef = doc(getNotesCollectionRef(), noteId);
                    const noteDocSnap = await getDoc(noteRef);
                    const noteData = noteDocSnap.data();
                    if (noteData.attachmentURL && noteData.attachmentPath && noteData.attachmentName && existingAttachmentDisplay.style.display === 'flex') {
                        attachmentURL = noteData.attachmentURL;
                        attachmentPath = noteData.attachmentPath;
                        attachmentName = noteData.attachmentName;
                    }
                }
            } catch (error) {
                console.error("Error al subir el archivo:", error);
                fileUploadStatus.textContent = `Error al subir archivo: ${error.message}`;
                fileUploadStatus.classList.add('error');
                // No retornar, permitir guardar la nota sin adjunto si la subida falla
            }

            if (noteId) {
                const noteRef = doc(getNotesCollectionRef(), noteId);
                await updateDoc(noteRef, {
                    title: noteTitle,
                    content: noteContent,
                    attachmentURL: attachmentURL,
                    attachmentPath: attachmentPath,
                    attachmentName: attachmentName
                });
            } else {
                await addDoc(getNotesCollectionRef(), {
                    title: noteTitle,
                    content: noteContent,
                    createdAt: new Date().toISOString(),
                    attachmentURL: attachmentURL,
                    attachmentPath: attachmentPath,
                    attachmentName: attachmentName
                });
            }
            noteModal.style.display = 'none';
            fetchAndRenderNotes();
            fileUploadStatus.style.display = 'none'; // Ocultar estado después de guardar
        });

        // Event listener para eliminar el adjunto existente desde el modal de edición
        deleteAttachmentButton.addEventListener('click', async () => {
            const noteId = noteIdInput.value;
            if (noteId) {
                const noteRef = doc(getNotesCollectionRef(), noteId);
                const noteDocSnap = await getDoc(noteRef);
                const noteData = noteDocSnap.data();

                if (noteData && noteData.attachmentPath) {
                    const fileRef = ref(storage, noteData.attachmentPath);
                    try {
                        await deleteObject(fileRef);
                        console.log("Adjunto eliminado de Storage:", noteData.attachmentPath);
                        await updateDoc(noteRef, {
                            attachmentURL: null,
                            attachmentPath: null,
                            attachmentName: null
                        });
                        existingAttachmentDisplay.style.display = 'none'; // Ocultar
                        fileUploadStatus.textContent = 'Adjunto eliminado con éxito.';
                        fileUploadStatus.classList.remove('error');
                        fileUploadStatus.classList.add('success');
                        fileUploadStatus.style.display = 'block';
                    } catch (error) {
                        console.error("Error al eliminar adjunto de Storage:", error);
                        fileUploadStatus.textContent = `Error al eliminar adjunto: ${error.message}`;
                        fileUploadStatus.classList.remove('success');
                        fileUploadStatus.classList.add('error');
                        fileUploadStatus.style.display = 'block';
                    }
                }
            }
        });


        // Event listener para la búsqueda de notas
        noteSearchInput.addEventListener('input', () => {
            const searchTerm = noteSearchInput.value.trim();
            fetchAndRenderNotes(searchTerm);
        });

        /**
         * Actualiza la visualización de la fecha actual en el encabezado.
         */
        const updateDate = () => {
            const options = { weekday: 'long', day: 'numeric', month: 'long' };
            const today = new Date();
            const formattedDate = today.toLocaleDateString('es-ES', options);
            dateDisplay.textContent = formattedDate.charAt(0).toUpperCase() + formattedDate.slice(1);
        };

        // Cuando el DOM esté completamente cargado, inicializar la aplicación
        document.addEventListener('DOMContentLoaded', () => {
            updateDate();
            // fetchAndRenderTasks('all') y renderDashboardCounts() se llaman después de la autenticación
        });
    </script>
</body>
</html>
